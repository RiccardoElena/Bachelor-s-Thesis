\chapter{Fluted Fragment}\label{chap:fluted-fragment}

As previously mentioned, undecidability of FOL has led to the systematic exploration of fragments that retain desirable properties while being decidable with resolution-based systems.

The definition of these fragments is tied to syntactic restrictions on the formulae, allowing the formulation of a terminating decision procedure exploiting the structure of the fragments.

Early investigations into decidable fragments often focused on restricting quantification, limiting formulae to a specific quantifier pattern.
Some notable examples are the \emph{Bernays-Schönfinkel class} (\(\exists^*\forall^*\)), the \emph{initially extended Ackermann class} (\(\exists^*\forall\exists^*\)), and the \emph{initially extended Gödel class} (\(\exists^*\forall\forall\exists^*\)).

Another notable example is the \emph{(loosely) guarded fragment}, which restricts quantification to conditional quantifiers of the form \(\forall \bar{y} (G(\bar{x},\bar{y}) \rightarrow \phi)\) or \(\exists \bar{y} (G(\bar{x},\bar{y}) \land \phi)\), where \(G\) is a \emph{guard} formula satisfying certain restrictions.

Other form of restrictions involve the arity of predicates, such as the \emph{monadic fragment}, which only allows unary predicates, or the \emph{two-variable fragment} (\(\text{FO}^2\)), which restricts formulae to at most two variables.

By contrast, the restriction of first-order logic which ensures decidability for fluted logic is an ordering on variables and arguments.

This variable-ordering approach is significant because it does not limit formulae structure or predicate arity, but only predicate application on variables.

Another significant aspect of fluted logic is the relationship to non-classical logics, such as extended modal logics and expressive description logics, which play an increasingly important role in various areas of computer science.
Fluted logic may be viewed as a generalization of modal logic, a characteristic shared with the guarded fragments. 
However, fluted logic offers advantages over guarded fragments for modal logic embeddings because it allows negation of relation atoms, enabling it to capture enriched modal logics like Boolean modal logic~\cite{gargov1990boolean}, and expressive description logics such as \(\mathcal{ALB}\) (without converse)~\cite{hustadt2000issues}.

Additionally, in~\cite{purdy1999quine} \citeauthor{purdy1999quine} describes an application in computational linguistics of fluted logics for
modelling ordinary English.

Finally, fluted logic has the finite model property~\cite{purdy1996decidability,purdy1996fluted,purdy1999quine}, which means that every satisfiable formula has a finite model.
This property is crucial because it enables decidable satisfiability checking through systematic enumeration of finite structures.

\section{Fluted Formulae}\label{sec:fluted-formulae}

Formally, the syntactic structure of fluted formulae can be defined as follows~\cite{schmidt2000resolution}:

\begin{definition}\label{def:fluted-formulae}
  Let \(\mathcal{P}\) be a finite set of predicate symbols and let \(X_m = \{x_1, \ldots, x_m\} \subseteq \mathcal{X}\)\uninatodo{this definition is taken directly from the paper but seems to not include the \(\emptyset\). Should I change it?} be an \emph{ordered} set of variables.
  An \emph{atomic fluted formula} of \(\mathcal{P} \text{ over } X_i\) is an \(n\)-ary atom \(P(x_l,\ldots, x_i)\), with \(l = i - n + 1 \text{ and } n \leq i\).
  \emph{Fluted formulae} are defined inductively as follows:
  \begin{enumerate}
    \item Any atomic fluted formula over \(X_i\) is a fluted formula over \(X_i\).
    \item \(\exists x_{i+1}\phi \text{ and } \forall x_{i+1}\phi\) are fluted formulae over \(X_{i}\), if \(\phi\) is a fluted formula over \(X_{i+1}\).
    \item Any Boolean combination of fluted formulae over \(X_i\) is a fluted formula over \(X_i\). That is, \(\phi \implies \psi, \neg \phi, \phi \land \psi\) are all fluted formulae over \(X_i\), if both \(\phi\) and \(\psi\) are.
  \end{enumerate}
\end{definition}

By definition, for any formula \(\phi\), if there is a variable renaming \(h\) such that \(h(\phi)\) is a fluted formula according to the above definition then \(\phi\) is a fluted formula.

Moreover, as a consequence of the definition, any fluted formula over \(X_i\) has \(X_i\) as its set of free variables, and therefore fluted sentences can be seen as over \(X_0 = \emptyset\).

In this definition, to quantify a fluted formula the quantified variable is forced to be the last free variable occurring in all predicate. In this sense, quantifying a formula to a sentence can be informally thought of as popping off variables from the list of free variables, which converges to \(X_0\).

% The semantics of fluted logic is defined as in FOL (\ref{subsec:semantics}).

Examples of fluted formulae are:
\begin{equation}\label{eq:fluted-example}
  \begin{aligned}
    \forall x_1 (P(x_1) \iff &\exists x_2(Q(x_2) \land R(x_1, x_2)))\\
    \forall x_1,x_2 (P(x_1,x_2) \iff &  (Q(x_1,x_2) \land\\
                                     &  \forall x_3 (R(x_1,x_2,x_3) \implies \exists x_4 Q(x_3,x_4))))
  \end{aligned}
\end{equation}

While the following examples are not fluted formulae:

\begin{equation}\label{eq:not-fluted-example}
  \begin{aligned}
    \forall x_1,x_2(P(x_1,x_2) \land \forall x_3(Q(x_3,x_1,x_2) \implies R(x_3)))\\
    \forall x_1,x_2(P(x_1,x_2) \land \exists x_3(Q(x_1,x_2,x_3) \implies \exists x_4 R(x_4,x_3)))
  \end{aligned}
\end{equation}
because the ordering of arguments is violated.

These constraints can be expressed less formally with a top-down approach as well, where the variables of atoms from a string \(fs\), where \(f\) is a possibly empty string of free variables, and \(s\) is a suffix of the string of the bound variables from the outermost quantifier to the innermost.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[syntree, scale=0.9]
        \node[quantifier] {\(\forall x_1\)}
          child{ node [quantifier] {\(\forall x_2\)}
            child { node[connective] {\(\iff\)}
              child { node[literal] {\(P(x_1, x_2)\)} }
              child { node[connective] {\(\land\)}
                child { node[literal] {\(Q(x_1, x_2)\)} }
                child { node[quantifier] {\(\forall x_3\)}
                  child { node[connective] {\(\implies\)}
                    child { node[literal] {\(R(x_1, x_2, x_3)\)} }
                    child { node[quantifier] {\(\exists x_4\)}
                      child { node[literal] {\(Q(x_3, x_4)\)} }
                    }
                }
              }
              }
            }
          };
    \end{tikzpicture}
    \caption{Syntactic tree for last example in Equation~\ref{eq:fluted-example} without quantifiers flattening}\label{fig:fluted_syntree}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[syntree,scale=0.9]
        \node[quantifier] {\(\forall x_1\)}
          child{ node [quantifier] {\(\forall x_2\)}
            child { node[connective] {\(\land\)}
              child { node[literal] {\(P(x_1, x_2)\)} }
              child { node[quantifier] {\(\exists x_3\)}
                child { node[connective] {\(\implies\)}
                  child { node[literal] {\(Q(x_1, x_2, x_3)\)} }
                  child { node[quantifier] {\(\exists x_4\)}
                    child { node[literal] {\(R(x_4, x_3)\)} }
                  }
                }
              }
            }
          };
    \end{tikzpicture}
    \caption{Syntactic tree for first example in Equation~\ref{eq:not-fluted-example} without quantifiers flattening}\label{fig:not_fluted_syntree}
\end{figure}

From the syntactic tree in Figure~\ref{fig:fluted_syntree}, it is easy to see that each atom has as arguments a suffix of the string of bound variables obtained from the traversal of the branch of the tree with the atom as leaf.

By contrast, in Figure~\ref{fig:not_fluted_syntree}, the atom \(R(x_4, x_3)\) had as argument string \(x_4 x_3\), which is not a suffix of the string of bound variables \(x_1 x_2 x_3 x_4\).

This observation leads to the fact that, in \dquote{\emph{constructing}} a fluted sentence top-down, one can only \emph{introduce} new variables at the end of the string and the variables an atom \(P\) is applied to is completely determined by the quantifiers it is in scope of and its arity, while everything remains arbitrary.

\section{Fluted Clauses}\label{sec:fluted-clauses}

In~\cite{schmidt2000resolution}, \citeauthor{schmidt2000resolution} introduces a restricted class of clauses named \bold{fluted clauses}.
These clauses are characterized by a specific structure that adheres to the constraints outlined in the previous sections and such that any fluted formula, after the necessary naming, can be transformed into a fluted clause.

Before we delve into the formal definition of the fluted clauses class, we need to introduce some notation.

The notation \(\flseq{i}\) will denote a finite, possibly empty, sequence \((u_i,u_{i+1}, \ldots, u_m)\) of terms. Unless specified otherwise each non-empty sequence \(\flseq{i}\) will be assumed to end with \(u_m\).

The sequences \(\flseq{1},\flseq{2},\ldots,\flseq{m}\) are therefore linearly ordered by the converse of the proper suffix relation and the sequence \(\flseq{m}\).
Therefore, the following notations will be used:
\begin{itemize}
  \item \(\flseq{i}[t]\) will denote the sequence \((u_i,u_{i+1}, \ldots, u_m,t)\).
  \item \(f\flseq{i}\) will denote the term \(f(u_i,u_{i+1}, \ldots, u_m)\).
  \item \(P\flseq{i}\) will denote the predicate \(P(u_i,u_{i+1}, \ldots, u_m)\).
  \item \(C\flseq{i}\) will denote a (possibly empty) clause of literals of the form \((\neg)P\flseq{i}\).
\end{itemize}

For \(f\flseq{i},P\flseq{i} \text{ and } C\flseq{i} \), \(\flseq{i}\) is called the \emph{argument sequence} of the corresponding term, predicate or clause.

If \(\flseq{i}\) is empty, then \(f\flseq{i}, P\flseq{i} \text{ and } C\flseq{i}\) respectively denote a constant, a propositional literal and a (possibly empty) propositional clause.

\begin{definition}\label{def:fluted-sequence}
Given \(m,n \in \mathbb{N} \text{ and } X_m = \{x_1,x_2,\ldots,x_m\}\) as previously defined, we will refer as to the sequence of terms \(\overline{u} = (u_1,u_2,\ldots,u_n)\) as a \emph{fluted sequence} over \(X_m\), if all the following conditions hold:
\begin{enumerate}[label= (\roman*)]
  \item \(n > m\);
  \item \(u_1=x_1,\ldots,u_m=x_m\);
  \item the number of variables occurring in \((u_{m+1},\ldots,u_n)\) is \(m\);
  \item for every \(k \in \{m+1,\ldots,n\}\), there is an \(i \in \{1,\ldots,k-1\}\) such that \\\(u_k = f(u_i,\ldots,u_{k-1})\) for some function symbol \(f\).
\end{enumerate}
The sequence \((x_1, \ldots, x_m)\) will be called the \emph{variable prefix} of \(\overline{u}\).
\end{definition}

This set of conditions serves the purpose of ensuring that the sequence of terms \(\overline{u}\) is constructed naturally extending the ordered set of variables \(X_m\) by introducing new functional terms whose argument sequences are suffixes of the \emph{fluted sequence} that precedes them.

Examples of fluted sequences are:
\begin{itemize}
  \item \((a)\), a fluted sequence over \(X_0=\emptyset\)
  \item \((x_1,x_2,x_3,f(x_1,x_2,x_3))\)
  \item \((x_1,x_2,x_3,f(x_2,x_3),g(x_1,x_2,x_3,f(x_2,x_3)))\)
  \item \((x_1,x_2,f(x_1,x_2),g(f(x_1,x_2)),h(x_2,f(x_1,x_2),g(f(x_1,x_2))))\)
\end{itemize}
while the following are not:
\begin{enumerate}[label= (\roman*)]
  \item \((x_1,x_2)\) over \(X_3\);\footnote{The sequence would have been fluted if it had been over \(X_2\) or \(X_1\) or \(X_0\).};
  \item \((x_1,x_2,f(x_3,x_4),x_3)\);
  \item \((x_1,x_2,x_3,f(x_3))\);
  \item \((x_1,x_2,x_3,f(x_3),g(x_1,x_2,x_3))\);
\end{enumerate}
because they violate respectively conditions (i), (iv), (iv) and (iv) of Definition~\ref{def:fluted-sequence}.

Moreover, these constraints ensure that the DAG representation of the fluted sequence has a unique total topological ordering providing another possible order on functional terms\footnote{Technically, the sequence ordering corresponds to the topological ordering in the \emph{transposed DAG}, with the one induced by the edges in the original DAG being its dual.}.
This can be easily shown by observing that, for every \(n\) only the vertex corresponding to \(u_n\) has in-degree zero, and therefore it must be the first vertex in any topological ordering of the DAG\@. Removing that vertex (and therefore that term) will again leave a DAG (and a fluted sequence) where only one vertex has in-degree zero (\(u_{n-1}\)), and so on until all vertices \(u_{m+1},\ldots, u_n\) are removed.

\begin{figure}[H]
\centering
\begin{tikzpicture}[syntree]
  % Nodi
  \node[literal] (x) at (-2,0) {\(X_m\)};
  \node[literal] (f) at (0,0) {\(f\)};
  \node[literal] (g) at (2,0) {\(g\)};
  \node[literal] (h) at (4,0) {\(h\)};
  
  \draw[-latex, thick] (f) -- (x);
  \draw[-latex, thick, bend right=30] (g) to (x);
  \draw[-latex, thick] (g) -- (f);
  \draw[-latex, thick, bend right=30] (h) to (x);
  \draw[-latex, thick, bend left=30] (h) to (f);
  \draw[-latex, thick] (h) -- (g);
\end{tikzpicture}
\caption{DAG of last example of fluted sequences}
\end{figure}
Is possible now to define the class of fluted clauses.

\begin{definition}\label{def:fluted-clauses}
  A clause \(C\) is a \emph{fluted clause} over \(X_m\) if one of the following conditions holds:
  \begin{description}
    \item[(FL0)] \(C\) is a (possibly empty) propositional clause.
    \item[(FL1)] \(C\) is not empty, the set of variables occurring in \(C\) (denoted \(\var{C}\)) is exactly \(X_m\), and for any literal \(L\) in \(C\), there is some \(i \in \{1,\ldots,m\}\) such that the argument sequence of \(L\) is
      \[(x_i, x_{i+1}, \ldots, x_m).\]
    \item[(FL2)] \(C\) is functional and not empty, \(\var{C} = X_m\), and for any literal \(L\) in \(C\), the argument sequence of \(L\) is one of
      \[(x_{i},x_{i+1}, \ldots, x_{i_m}) \text{ or }\]
      \[(u_j, u_{j+1}, \ldots, u_{n}),\]
    where \(1 \leq i \leq m\) and \((u_j, u_{j+1}, \ldots, u_{n})\) is a suffix of some fluted sequence \(\overline{u} \text{ over } \{x_k, \ldots, x_m\}\) with \(k \in \{1,\ldots,m\}\).
    \(\overline{u}\) will be referred to as the \emph{fluted sequence associated} with \(L\).
    \item[(FL3)] \(C\) is not empty, \(\var{C} = X_{m+1}\), and for any literal \(L\) in \(C\), the argument sequence of \(L\) is either
      \[(x_{1},x_{2}, \ldots, x_{m}) \text{ or }\]
      \[(x_{i},x_{i+1}, \ldots, x_{m},x_{m+1}),\]
    where \(1 \leq i \leq m+1\).
  \end{description}
  A fluted clause will be called \emph{strongly fluted clause} if it is either ground or has a literal which contains all the variables of the clause.
\end{definition}

Some examples of fluted clauses are:
\begin{description}
  \item[(FL0)] \(\neg P \lor Q \lor R\)
  \item[(FL1)] \(P(x_1,x_2,x_3,x_4,x_5) \lor Q(x_1,x_2,x_3,x_4,x_5) \lor \neg R(x_4,x_5) \lor S(x_5)\)
  \item[(FL2)] \(Q(x_1,x_2) \lor R(x_2) \lor P(x_1,x_2,f(x_1,x_2))\lor R(x_2,f(x_1,x_2)) \lor S(f(x_1,x_2))\)
  \item[(FL3)] \(Q(x_1,x_2) \lor \neg P(x_1,x_2,x_3) \lor \neg R(x_2,x_3) \lor S(x_3)\)
\end{description}

Some additional notes:
\begin{enumerate*}[label= (\alph*)]
  \item The non-functional subclause of a (FL2)-clause (denoted by \(\nabla\)) satisfies (FL1), therefore (FL1)-clauses are building blocks of (FL2)-clauses.
  \item Clauses of type (FL3) are defined to be fluted clauses over \(m\) variables, even though they contain \(m+1\) variables. This is to ensure direct association of fluted formulae over \(m\) variables with fluted clauses over \(m\) variables. The previous example of (FL3)-clause is therefore over \(2\) variables.
  \item No fluted clause can simultaneously satisfy multiple fluted conditions at once.
\end{enumerate*}

Strongly fluted clauses will be the core of the resolution procedure assuring its termination.
That is because, resolving two strongly fluted clauses and selecting as eligible literal the literal containing all the variable of the clause, will produce a resolvent with a number of variables less than or equal to the number of variables of the parent clauses.

Some additional property of fluted clauses come from the following results.
The proofs follow straightforwardly and are therefore omitted for brevity. Complete demonstration for these lemmas, and for all other claims in this chapter, can be found in~\cite{hustadt2000resolution}.

\begin{lemma}\label{lem:fluted-sequence-properties}
  Let \(\overline{u}\) be a fluted sequence over \(X_m\). Then:
  \begin{enumerate}
    \item There is an element \(u_k\) of \(\overline{u}\) such that \(u_k = f(u_1,\ldots,u_{k-1})\), for some \(f\)
    \item If \(u_n\) is the last element of \(\overline{u}\), then \(\var{u_n} = X_m\)
    \item \(\overline{u}\) is uniquely determined by its last element
    \item if \(u_j, u_{j+1}, \ldots, u_n\) is a suffix of \(\overline{u}\), then \(u_1, \ldots, u_{j-1}\) is uniquely determined by \(u_j\)
  \end{enumerate}
\end{lemma}

\begin{lemma}\label{lem:var-sequence-fl2}
  Let \(L\) be any literal of a (FL2)-clause defined over \(X_m\). Then, all occurrences of variable sequences in \(L\) are suffixes of \(x_1, \ldots, x_m\).
\end{lemma}

\begin{lemma}\label{lem:strongly-fluted-clauses}
  Let \(C\) be a fluted clause over \(m\) variables. \(C\) is strongly fluted if and only if:
  \begin{enumerate*}[label= (\roman*)]
    \item \(C\) satisfies exactly one of the conditions (FL0), (FL1), (FL2), or
    \item \(C\) satisfies condition (FL3), and it contains a literal with \(m+1\) variables.
  \end{enumerate*}
\end{lemma}

Lemma~\ref{lem:strongly-fluted-clauses} is of particular relevance, because it assures that any fluted clause is indeed strongly fluted, except for some (FL3)-clauses. Those exceptions will be handled with a new inference rule named \emph{separation} that will be introduced later.

\section{From Fluted Formulae to Fluted Clauses}\label{sec:from-fluted-formulae-to-fluted-clauses}

Once defined the class of fluted clauses, a procedure to transform any fluted formula into a set of fluted clauses is needed.

This transformation is obtained by pre-pending to standard clausification defined in Section~\ref{sec:skolemization_and_normalization} a step of \emph{renaming}, as mentioned in Section~\ref{sec:auxiliary_predicate_introduction}, that guarantees the preservation of the fluted structure.

In particular, the renaming technique used is also known as \emph{structural transformation}.

To describe this \emph{renaming} step more formally it is sufficient to define a function that maps any fluted formula \(\phi\) over \(X_m\) to a fluted formula \(t(\phi)\) over \(X_m\) that, after the standard clausification, produces a set of fluted clauses.

Let \(Pos(\phi)\) be the set of positions of a first-order formula \(\phi\). If \(\lambda\) is in \(Pos(\phi)\), then \(\phi|_\lambda\) denotes the subformula of \(\phi\) at position \(\lambda\) and, extending the previously introduced notation for substitution, \(\phi[\psi\mapsto\lambda]\) is the result of replacing \(\phi|_\lambda\)  at position \(\lambda\) with \(\psi\).

Looking at formulae from the prospective of their syntactic tree, \(Pos(\phi)\) can be seen as the set of all nodes in the tree visited in a pre-order traversal, \(\phi|_\lambda\) is the subtree rooted at node \(\lambda\), and \(\phi[\psi\mapsto\lambda]\) is tree obtained by replacing the subtree rooted at node \(\lambda\) with the tree of \(\psi\).
Structural transformations associates with each element \(\lambda \in \Lambda \subseteq Pos(\phi)\) a fresh predicate symbol \(Q_\lambda\) and a literal \(Q_\lambda(x_1,\ldots,x_n)\), where \(x_1,\ldots,x_n\) are the free variables of \(\phi|_\lambda\), such that any two symbols \(Q_\lambda \text{ and } Q_{\lambda'}\) are equal only if \(\phi|_\lambda\) and \(\phi|_{\lambda'}\) are equivalent formulae.

Let 
  \[\fldef{\lambda}[+]{\phi} = \forall x_1, \ldots, x_n(Q_\lambda(x_1,\ldots,x_n)\implies \phi|_\lambda) \text{ and}\]
  \[\fldef{\lambda}[-]{\phi} = \forall x_1, \ldots, x_n(\phi|_\lambda \implies Q_\lambda(x_1,\ldots,x_n)).\]

The \emph{definition} of \(Q_\lambda\) is the formula
\begin{equation}
  \fldef{\lambda}{\phi} = \begin{cases}
                        \fldef{\lambda}[+]{\phi} & \text{if } \phi|_\lambda \text{has positive polarity}\\
                        \fldef{\lambda}[-]{\phi} & \text{if } \phi|_\lambda \text{has negative polarity}\\
                        \fldef{\lambda}[+]{\phi} \land \fldef{\lambda}[-]{\phi} & \text{otherwise}
                      \end{cases}
\end{equation}
The corresponding clauses are called \emph{definitional clauses}.

Is possible to inductively extends \emph{definition} to the whole set of positions \(\Lambda\) (\(Def_\Lambda(\phi)\)) as follows:
\begin{equation}
  \begin{aligned}
    \fldef{\emptyset}{\phi} &= \phi\\
    \fldef{\Lambda\cup\{\lambda\}}{\phi} &= \fldef{\Lambda}{\phi[Q_\lambda(x_1,\ldots,x_n)\mapsto\lambda]} \land \fldef{\lambda}{\phi}
  \end{aligned}
\end{equation}
where \(\lambda\) is maximal in \(\Lambda\cup\{\lambda\}\) with respect to the prefix ordering on positions.

For any first-order formula \(\phi\), \(\fldef{\Lambda}{\phi}\) will denote the \emph{definitional form} obtained by introducing new names for subformulae at positions in \(\Lambda\).
This transformation can be seen as substituting each node of the syntactic tree in \(\Lambda\) with a fresh literal \(Q_\lambda(x_1,\ldots,x_n)\) in post-order, adding the definition of \(Q_\lambda\) as a child of a new root node for the \(\land\) connective.

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{.3\textwidth}
    \begin{tikzpicture}[syntree]
      \node[quantifier] {\(\forall x\)}
            child { node[connective] {\(\implies\)}
              child { node[literal] {\(P(x)\)} }
              child { node[quantifier] {\(\exists y\)}
                  child { node[literal] {\(R(x, y)\)} }
              }
            };
    \end{tikzpicture}
  \end{minipage}
  \begin{minipage}[t]{.3\textwidth}
    \begin{tikzpicture}[syntree,
                        level 1/.style={sibling distance=3cm},
                        level 2/.style={sibling distance=2cm},
                        level 3/.style={sibling distance=1.5cm}
                        ]
      \node[connective] {\(\land\)}
            child {node[quantifier] {\(\forall x\)}
              child { node[connective] {\(\implies\)}
                child { node[literal] {\(Q_3(x)\)} }
                child { node[literal] {\(\exists y\)}
                  child { node[literal] {\(R(x, y)\)} }
                }
              }
            }
            child{node[quantifier] {\(\forall x\)}
              child { node[connective] {\(\implies\)}
                child { node[literal] {\(P(x)\)} }
                child { node[literal] {\(Q_3(x)\)} }
              }
            };
    \end{tikzpicture}
  \end{minipage}
  \caption{Structural transformation of a formula into its definitional form with \(\Lambda = \{3\}\).}\label{fig:definitional-form}
\end{figure}

Usually \(\Lambda\) is the subset of all positions of subformulae which are non-atomic or non-literal.

For the problem of decidability is important that this transformation preserves satisfiability. Indeed, the following theorem holds:

\begin{theorem}\label{thm:definitional-sat-preservation}
  Let \(\phi\) be a first-order formula. For any \(\Lambda \subseteq Pos(\phi)\),
  \begin{enumerate}
    \item \(\phi\) is satisfiable if and only if \(\fldef{\Lambda}{\phi}\) is satisfiable;
    \item \(\fldef{\Lambda}{\phi}\) can be computed in polynomial time.
  \end{enumerate}
\end{theorem} 

It is therefore possible to show that any fluted formula \(\phi\), introducing new literals for each non-literal subformula position, can be transformed into a set of strongly fluted clauses.

\begin{lemma}
  Let \(\phi\) be any fluted formula. If \(\Lambda\) contains all non-literal subformulae positions of \(\phi\) then the clausification of \(\fldef{\Lambda}{\phi}\) is a set of strongly fluted clauses (provided the newly introduced literals have the form \((\neg)Q_\lambda(\overline{x}_i)\)).
\end{lemma}

To instead obtain a set of fluted clauses (not necessarily strongly fluted) it is required to introduce new symbols only for the quantified subformulae\footnote{Technically in~\cite{hustadt2000resolution} is mentioned, that only requires the introduction of new symbols for positive occurrences of universally quantified subformulae, negative occurrences of existentially quantified subformulae and all quantified subformulae with zero polarity, but then another form of Skolemization needs to be used. }.

\begin{lemma}\label{lem:fluted-def-constraints}
  Let \(\phi\) be any fluted formula over \(X_m\). If \(\Lambda\) contains at least the positions of any subformulae \(\exists x_{i+1}\psi, \forall x_{i+1}\psi\), then the clausification of \(\fldef{\Lambda}{\phi}\) is a set of fluted clauses (again, provided the newly introduced literals have the form \((\neg)Q_\lambda(\overline{x}_i)\)).
\end{lemma}

The loss of strong property of the generated clauses is due to \(\fldef{\lambda}[-]{\phi}\) of existentially quantified subformulae (and to \(\fldef{\lambda}[+]{\phi}\) of universally quantified subformulae by duality).
This is easy to show considering the subformula at position \(\lambda\):
  \[
    \exists x_3 (P(x_1,x_2,x_3) \lor R(x_2,x_3))
  \]
that leads to the negative definition
  \[
    \fldef{\lambda}[-]{\phi} = \forall x_1,x_2(\exists x_3 (P(x_1,x_2,x_3) \lor R(x_2,x_3)) \implies Q_\lambda(x_1,x_2))
  \]
whose clausification to the (FL3)-clauses
  \[
    Q_\lambda(x_1,x_2) \lor \neg P(x_1,x_2,x_3)
  \]
  \[
    Q_\lambda(x_1,x_2) \lor \neg R(x_2,x_3)
  \]
of which the latter does not contain a literal which contains all the variables of the clause, and is thus only fluted, not strongly fluted.

Having only fluted clauses and not strongly fluted ones in this phase is not a problem because, as we will see later, resolution of strongly fluted clauses can produce a non-strongly fluted clauses, making a procedure to obtain equivalent strongly fluted clauses from non-strongly fluted ones necessary anyway.

This procedure is the new inference rule named \bold{separation}.
\section{Separation}\label{sec:separation}
As briefly mentioned in the previous section, the motivation for introducing the \emph{separation} inference rule is that the class of fluted clauses is not closed under resolution.
In particular, resolvents of non-strongly fluted (FL3)-clauses are not always fluted and can cause (potentially) unbound variable chaining across literals.

This can be shown considering the resolution between
  \[
    P_1(x_1,x_2) \lor Q_1(x_2,x_3) \lor R(x_2,x_3) \text{ and }
  \]
  \[
  \neg R(x_1,x_2) \lor P_2(x_1,x_2) \lor Q_2(x_2,x_3)
  \]
which produces the resolvent
  \[
    P_1(x_1,x_2) \lor Q_1(x_2,x_3) \lor P_2(x_2,x_3) \lor Q_2(x_3,x_4)
  \]
that is not fluted and contains more variables than the original clauses.

The class of strongly fluted clauses is also not closed under resolution but, inferences with two strongly fluted clauses always produce fluted clauses, and non-strongly fluted clauses are what we call separable and can be restored to strongly fluted clauses.

Consider the strongly fluted clauses
  \[
    P(x_1,x_2) \lor R(x_1,x_2,x_3) \text{ and }
  \]
  \[
  \neg R(x_1,x_2,x_3) \lor P(x_2,x_3)
  \]
whose resolvent is
  \[
    C = P(x_1,x_2) \lor P(x_2,x_3)
  \]

\(C\) satisfies (FL3) but it is not strongly fluted, as none of its literals contains all the variables of the clause.

A consequence of this, is that the literals are incomparable under an admissible ordering (in particular, a liftable ordering), because the literals have a common instance, for example
  \[
    C\{x_1 \mapsto a, x_2 \mapsto a, x_3 \mapsto a\} = P(a,a) \lor P(a,a)
  \]

The problem is caused by the variable \(x_1 \text{ and } x_3\). Because they do not occur together in any literal, \(C\) can be separated and replaced by the following two clauses, where \(Q\) is a new predicate symbol.
  \[
    Q(x_2) \lor P(x_1,x_2)
  \]
  \[
    \neg Q(x_2) \lor P(x_2,x_3)
  \]
These two clauses are indeed strongly fluted, the first satisfying (FL1) and the second (FL3) but being strongly fluted.

This process of separating non-strongly fluted clauses into strongly fluted can be formalized in the \bold{separation} inference rule, that can be used outside the context of fluted logic as well.

\begin{definition}
  Let \(C\) be an arbitrary clause. \(C\) is \bold{separable} if it can be partitioned into two non-empty subclauses \(D_1\) and \(D_2\) such that \(\var{D_1} \not\subseteq \var{D_2} \text{ and } \var{D_2} \not\subseteq \var{D_1}\)
\end{definition}

For example the clause shown before is separable, while the clause
\[
P(x_1,x_2) \lor Q(x_2,x_3) \lor R(x_1,x_3)
\]
is not separable.
\begin{theorem}\label{thm:separation}
  Let \(C \lor D\) be a separable clause such that \(\var{C} \cap \var{D} = \{x_1,\ldots,x_n\}\) for \(n \in \mathbb{N}\).
  Let \(Q\) be a fresh predicate symbol with arity \(n\).
  Then a set of clauses \(N \cup \{C\lor D\}\) is satisfiable if and only if the set of clauses \(N \cup \{\neg Q(x_1,\ldots, x_n) \lor C, Q(x_1,\ldots, x_n) \lor D\}\) is satisfiable.
\end{theorem}

On the basis of this theorem we can define the following replacement rule:

\begin{equation}\label{eq:separation-rule}
  \bold{Separation:} \quad \infer{N \cup \{\neg Q(x_1,\ldots, x_n) \lor C, Q(x_1,\ldots, x_n) \lor D\}}{N \cup \{C \lor D\}}
\end{equation}
\indent provided 
\begin{enumerate*}[label = (\roman*)]
  \item \(C \lor D\) is separable,
  \item \(\var{C} \cap \var{D} = \{x_1,\ldots,x_n\}\) for \(n \in \mathbb{N}\),
  \item \(Q\) is \indent a fresh predicate symbol with arity \(n\).
\end{enumerate*}

From the definition of separable clauses, also follows that
\begin{lemma}\label{lem:separation-replacement}
  The replacements of a separable clause \(C\) each contain less variable than \(C\)
\end{lemma}

Moreover, it is possible to prove the following.

\begin{theorem}
  Let \(R^{sep}\) denote the extension of \(R\) defined as in Section~\ref{sec:resolution-factoring} with the separation inference rule and let \(N\) be a set of clauses.
  Then \(N\) is unsatisfiable if and only if the saturation of \(N\) under \(R^{sep}\) contains the empty clause.
\end{theorem}

More generally, this theorem holds also if \(R^{sep}\) is based on ordered resolution

By Lemma~\ref{lem:strongly-fluted-clauses}, separable fluted clauses have the form
\begin{equation}\label{eq:separable-fluted-clauses}
  \mathcal{L}(\overline{x}_1)\lor \mathcal{L}(\overline{x}_i,x_{m+1}) \lor \ldots \lor \mathcal{L}(x_m, x_{m+1}) \lor \mathcal{L}(x_{m+1})
\end{equation}
where \(\mathcal{L}(\cdot)\) denotes a (possibly empty) disjunction of literals with non-empty argument sequence \((\cdot)\), \(\mathcal{L}(\overline{x}_1)\) is not empty and \(i\) is the smallest integer in \(\{2,\ldots, m\}\) such that \(\mathcal{L}(\overline{x}_i), x_{m+1}\) is not empty.

The separation of clauses i this form, will produce clauses with the form
\[
  \neg Q(\overline{x}_i) \lor \mathcal{L}(\overline{x}_1) \text{ and }
\]
\[
  Q(\overline{x}_i) \lor \mathcal{L}(\overline{x}_i,x_{m+1}) \lor \ldots \lor \mathcal{L}(x_m, x_{m+1}) \lor \mathcal{L}(x_{m+1})
\]
which are obviously strongly fluted, thanks to literals in \(\mathcal{L}(\overline{x}_1)\) and in \(\mathcal{L}(\overline{x}_i)\).

From this, follows that:
\begin{lemma}\label{lem:separation-fluted}
  The separation of a separable fluted clause~\ref{eq:separable-fluted-clauses} is a set of strongly fluted clauses
\end{lemma}
\begin{lemma}
  For fluted clauses a separation inference step can be performed in linear time
\end{lemma}


\section{Fluted Resolution}\label{sec:fluted-resolution}

In the end, we can formally define an ordered resolution based inference system \(R^{sep}\) whose application is a decision procedure for fluted logic.

The ordering \(\succ\) of \(R^{sep}\) is required to be any admissible ordering compatible with the following complexity measure.

\begin{definition}
  Let \(\succ_s\) denote the proper super-term ordering. Define the complexity measure of any literal \(L\) by \(c_L = (ar(L),max(L),sign(L))\), where \(ar(L)\) is the arity of \(L\), \(max(L)\) is a \(\succ_s\)-maximal term occurring in \(L\) and \(sign(L)\) is \(1\) if \(L\) is negative and \(0\) if \(L\) is positive. % chktex 35
  The ordering on the complexity measures is given by the lexicographic combination of \(>,\succ_s \text{ and } >\), where \(>\) is the usual ordering on natural numbers.
\end{definition}

Having the ordering \(\succ\) in place, we can now define the inference system \(R^{sep}\) more formally.

\begin{definition}
  Let \(R^{sep}\) be any inference system in which
  \begin{enumerate*}[label = (\roman*)]
    \item derivations are generated by removing redundant literals, separating separable clauses and deducing new clauses with the inferences in \(R\) in this order
    \item the ordering is based on \(\succ\), defined above.
  \end{enumerate*}
\end{definition}

It can be shown that the class of fluted clauses is closed under the inference system \(R^{sep}\) by the following lemmas.

\begin{lemma}\label{lem:factor-strongly-fluted}
  A factor of a strongly fluted clause \(C\) is again a strongly fluted clause of the same type.
\end{lemma}
In fact, any (unordered) factor of a strongly fluted clause \(C\) is again a strongly fluted clause of the same type.

\begin{lemma}
  Let \(C = C' \lor A_1\) and \(D = \neg A_2 \lor D'\) be (FL2)-clauses.
  Suppose \(A_1\) and \(A_2\) are eligible literals in \(C\) and \(D\) respectively, and that \(\sigma\) is the MGU of \(A_1\) and \(A_2\).
  Then:
  \begin{enumerate}
    \item \(C\sigma\), \(D\sigma\) and \(C\sigma \lor D\sigma\) are (FL2)-clauses.
    \item For any functional literal \(L\sigma\) in \(C\sigma \lor D\sigma\), the fluted sequence associated with \(L\sigma\) is the \(\sigma\)-instance of a fluted sequence \(\overline{v}\) associated with some literal \(L'\) in \(C \lor D\).
  \end{enumerate}
\end{lemma}

This lemma is the most important technical result of~\cite{hustadt2000resolution} because with it, we can easily show that the resolution of strongly fluted clauses involving (FL2)-clauses always produce strongly fluted clauses.
\begin{lemma}\label{lem:union-strongly-fluted}
  Let \(C = C' \lor A_1\) and \(D = \neg A_2 \lor D'\) be strongly fluted clauses. Suppose \(A_1\) and \(A_2\) are eligible literals in \(C\) and \(D\) respectively, and that \(\sigma\) is the MGU of \(A_1\) and \(A_2\).
  Then \(C\sigma \lor D\sigma\) is a strongly fluted clause.
\end{lemma}
\begin{lemma}\label{lem:removal-fluted}
  Removing any subclause from a fluted clause produces a fluted clause.
\end{lemma}
The combination of Lemmas~\ref{lem:union-strongly-fluted} and~\ref{lem:removal-fluted} leads to the closure of fluted clauses under ordered resolution.

\begin{lemma}\label{lem:resolution-fluted}
  The resolvent of any two strongly fluted clauses is a strongly fluted clause, or, it is only a fluted clause, if one of the premises is a (FL3)-clause
\end{lemma}

Moreover, it can be shown that:

\begin{lemma}\label{lem:size-fluted}
  Let \(C,D\) and \(\sigma\) defined as in Lemma~\ref{lem:union-strongly-fluted}. Then,
  \[ |\var{C\sigma \lor D\sigma} \leq \max\{ |\var{C\sigma}|,|\var{D\sigma}|\}\]
\end{lemma}
Finally, by Lemmas~\ref{lem:separation-fluted},~\ref{lem:factor-strongly-fluted} and~\ref{lem:resolution-fluted}, we can conclude that:
\begin{lemma}
  Any separated factor or resolvent of strongly fluted clauses is strongly fluted.
\end{lemma}

In the end, remains only to show that the application of \(R^{sep}\) constitutes a decision procedure for fluted logic, and so does terminate on each finite input set of clauses.

For doing this it is usually sufficient~\cite{joyner1976resolution} to show that:
\begin{enumerate}[label= (\roman*)]
  \item\label{item:bounded-variables} the number of variables in any derivable clause is finitely bounded;
  \item\label{item:bounded-depth} there is a bound on the depth of terms occurring in derived clauses;
  Because separation introduces new predicate names during the derivation, in our case we also need to show that:
  \item\label{item:bounded-separation} there is a bound on the number of applications of the separation rule.
\end{enumerate}

From Lemmas~\ref{lem:separation-replacement} and~\ref{lem:size-fluted}, follows immediately~\ref{item:bounded-variables} by:
\begin{lemma}\label{lem:bounded-variables}
  All clauses occurring in an (\(R^{sep}\))-derivation from \(N\) contain at most \(m+1\) variables, where \(m\) is the maximal arity of any predicate symbol in \(N\)
\end{lemma}

The definition of fluted clauses places no restriction on the level of nesting of functional terms. But:
\begin{lemma}\label{lem:bounded-depth}
  A bound on the maximal term depth of clauses derived by \(R^{sep}\) from \(N\) is \(m\), where \(m\) is the maximal arity of any predicate symbol in \(N\)
\end{lemma}
This lemma can be shown by observing that, as a consequence of Lemma~\ref{lem:strongly-fluted-clauses}, the maximal length of any fluted sequences associated with literals in inferred clauses does not increase and that the maximal term depth of any term is the length of the fluted sequence associated with it.
It follows that the maximal term depth for any derived clause is the maximal length of any fluted sequence of a literal in \(N\) that, is obviously \(m\), the maximal arity of any predicate symbol in \(N\).

Finally, remains to show~\ref{item:bounded-separation}.

\begin{lemma}\label{lem:bounded-separation}
  The number of applications of the separation rule in any (\(R^{sep}\))-derivation from \(N\) is bounded.
\end{lemma}

The idea of the proof is that the newly introduced literals is never eligible in the new clauses because its arity is always less than some literal in the clause.
Therefore, the two replacement of a separated clause cannot be resolved together recreating the original clause. The literals become eligible only when all other \dquoteit{bigger} literals are removed, leading to a non-increase of arity.

The theoretical discussion of the fluted fragment can therefore be said to be concluded with the enunciation of the last final theorem deriving directly from the previous lemmas.

\begin{theorem}
  Let \(\phi\) be any fluted formula and \(N\) be the clausification of \(\fldef{\Lambda}{\phi}\) satisfying the restrictions of Lemma~\ref{lem:fluted-def-constraints}.
  Then:
  \begin{itemize}
    \item Any \(R^{sep}\)-derivation from \(N\) terminates.
    \item \(\phi\) is unsatisfiable if and only if the \(R^{sep}\)-saturation of \(N\) contains the empty clause.
  \end{itemize}
\end{theorem}

\begin{proof}
  Termination is a consequence of Lemmas~\ref{lem:bounded-variables},~\ref{lem:bounded-depth} and~\ref{lem:bounded-separation}, while soundness and completeness follows from~\cite{robinson1965} alongside Theorems~\ref{thm:definitional-sat-preservation} and~\ref{thm:separation}, in conjunction with Lemma~\ref{lem:bounded-separation}
\end{proof}



